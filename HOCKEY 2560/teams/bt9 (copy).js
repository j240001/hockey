// Edmonton (EDM) - Generated by Builder V30 (Safe Mode)
(function() {
    const STRATEGY_ID = "BT_" + "EDM_" + Math.floor(Math.random() * 99999);

// --- ENGINE (V32 Label-Preserving Update) ---
    class Node { constructor() {} tick(bb) { return false; } }
    class ConditionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb) ? "SUCCESS" : "FAILURE"; } }
    
    class ActionNode extends Node {
        // Setting label = "Action" as a fallback
        constructor(fn, label = "NO NAME") { 
            super(); 
            this.fn = fn; 
            this.label = label; 
        }
        tick(bb) { 
            const res = this.fn(bb);
            if (res && typeof res === 'object') {
                // If no label was provided, it uses the fallback "Action"
                res.nodeLabel = this.label; 
            }
            return res || null; 
        }
    }

    class SequenceNode extends Node { 
        constructor(c) { super(); this.children = c; } 
        tick(bb) { 
            let lastRes = "SUCCESS";
            for (let n of this.children) { 
                let r = n.tick(bb); 
                if (r === "FAILURE" || !r) return "FAILURE";
                lastRes = r; // Ensures an Action result at the end of a sequence carries its label up
            } 
            return lastRes; 
        } 
    }

    class SelectorNode extends Node { 
        constructor(c) { super(); this.children = c; } 
        tick(bb) { 
            for (let n of this.children) { 
                let r = n.tick(bb); 
                if (r !== "FAILURE" && r !== false) return r; // Passes the labeled object up immediately
            } 
            return "FAILURE"; 
        } 
    }


    // --- CORE HELPERS (Math & Vision) ---
    function clamp(v, lo, hi) { return v < lo ? lo : (v > hi ? hi : v); }
    function normalizeAngle(a) { while (a <= -Math.PI) a += 2 * Math.PI; while (a > Math.PI) a -= 2 * Math.PI; return a; }
    function pointLineDistance(x1, y1, x2, y2, px, py) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A*C + B*D, lenSq = C*C + D*D;
        if (lenSq < 0.001) return Math.hypot(px - x1, py - y1);
        const t = Math.max(0, Math.min(1, dot / lenSq));
        return Math.hypot(px - (x1 + t * C), py - (y1 + t * D));
    }
    function getPlayerById(id) { return (typeof players !== 'undefined') ? players.find(p => p.id === id) : null; }
    function getPuckCarrier() { return (typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null; }
    function isLaneBlocked(x1, y1, x2, y2, team) {
        if (typeof players === 'undefined') return false;
        for (const o of players) {
            if (o.team === team) continue;
            // IGNORE GOALIE IN GENERAL BLOCK CHECKS
            if (o.type === 'goalie') continue; 
            if (pointLineDistance(x1, y1, x2, y2, o.x, o.y) < 18) return true;
        }
        return false;
    }


    function predictPuckIntersection(p) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x + 1, y: p.y };
        return { x: puck.x + puck.vx * 10, y: puck.y + puck.vy * 10 };
    }


    function getPuckIntercept(p, minSpeed = 1.5) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x + 1, y: p.y };
        
        // 1. Calculate current puck speed
        const puckSpeed = Math.hypot(puck.vx, puck.vy);
        
        // 2. BYPASS LOGIC: If puck is slower than your parameter, go directly to it
        if (puckSpeed < minSpeed) {
            return { x: puck.x, y: puck.y };
        }

        // 3. Standard Intercept Logic
        const dist = Math.hypot(puck.x - p.x, puck.y - p.y);
        const frames = dist / 4.0; 
        let tx = puck.x + puck.vx * frames;
        let ty = puck.y + puck.vy * frames;
        
        // Boundary Guards to keep them on the rink
        tx = Math.max(120, Math.min(880, tx));
        ty = Math.max(170, Math.min(430, ty));
        return { x: tx, y: ty };
    }
    


// --- UPDATED VISION CHECK (Supports Smart Shot Parameters) ---
    function canSeeNet(p, angleBuffer = 10, laneWidth = 15) {
        const goalX = (p.team === 0) ? (typeof goal2!=='undefined'?goal2:825) : (typeof goal1!=='undefined'?goal1:175);
        const goalY = (typeof RY !== 'undefined' ? RY : 300);
        
        const attackingRight = (goalX > 500);
        
        // Use the parameter passed from Smart Shot
        if (attackingRight) {
            if (p.x > goalX - angleBuffer) return false; 
        } else {
            if (p.x < goalX + angleBuffer) return false; 
        }

        for (const o of players) {
            if (o.team === p.team) continue;
            if (o.type === "goalie" || o.role === "Goalie") continue; 
            const distToShot = pointLineDistance(p.x, p.y, goalX, goalY, o.x, o.y);
            
            // Use the parameter passed from Smart Shot
            if (distToShot < laneWidth) return false;
        }
        return true;
    }


    // --- ACCURATE LEAD PREDICTION (Synced with 20-frame Delay) ---
    function predictLeadPass(passer, receiver) {
        const dx = receiver.x - passer.x;
        const dy = receiver.y - passer.y;
        const distNow = Math.hypot(dx, dy);
        if (distNow < 1 || isNaN(distNow)) return { x: receiver.x, y: receiver.y, t: 0 };

        const mentalDelay = 20; 
        let passSpeed = 5.5 + (distNow / 40.0);
        if (passSpeed > 14.0) passSpeed = 14.0;
        
        const travelFrames = distNow / passSpeed;
        const totalFrames = mentalDelay + travelFrames; 

        const leadX = receiver.x + (receiver.vx || 0) * totalFrames;
        const leadY = receiver.y + (receiver.vy || 0) * totalFrames;

        return { 
            x: Math.max(120, Math.min(880, leadX)), 
            y: Math.max(170, Math.min(430, leadY)), 
            t: travelFrames 
        };
    }

    
        // --- 1. INTEL TEST: Teammates only (Goalie Excluded) ---
        function intel_test(bb) {
            if (!bb || !bb.p || typeof players === 'undefined') return "FAILURE";
            for (let m of players) {
                // Must be teammate, not me, and NOT the goalie role
                if (m.team === bb.p.team && m.id !== bb.p.id && m.role !== "Goalie") {
                    let minDistance = 9999;
                    for (let o of players) {
                        if (o.team !== bb.p.team && o.type !== 'goalie') {
                            const d = Math.hypot(o.x - m.x, o.y - m.y);
                            if (d < minDistance) minDistance = d;
                        }
                    }
                    m.intel_nearestOppDist = minDistance; 
                }
            }
            return "FAILURE"; 
        }

        // --- MODIFIED CARRIER INTEL (Maintains Name) ---
        
        function carrier_intel(bb, isForward = 1) {
            if (!bb || !bb.p || typeof players === 'undefined') return "FAILURE";
            let minDistance = 9999;
            for (let o of players) {
                if (o.team !== bb.p.team && o.role !== "Goalie") {
                    if (isForward === 1) {
                        const relativeX = (o.x - bb.p.x) * bb.forwardDir;
                        if (relativeX < -20) continue; 
                    }
                    const d = Math.hypot(o.x - bb.p.x, o.y - bb.p.y);
                    if (d < minDistance) minDistance = d;
                }
            }
            bb.p.carrier_patience_dist = minDistance;
            return "FAILURE"; 
        }

      
        // --- 3. PASS TEST (Up-ice + Openness + Lane Check) ---
        function pass_test(bb, minOpenness = 40) {
            if (!bb || !bb.p || typeof players === 'undefined') return "FAILURE";
            let bestTeammate = null, maxUpIceScore = -Infinity;
            
            for (let m of players) {
                if (m.team === bb.p.team && m.id !== bb.p.id && m.role !== "Goalie") {
                    const safety = m.intel_nearestOppDist || 0;
                    
                    // 1. QUALIFICATION: Meets openness threshold?
                    if (safety >= minOpenness) {
                        
                        // 2. LANE CHECK: Is the path to this teammate clear?
                        // We pass bb.p.team to isLaneBlocked so it only checks opponents.
                        if (typeof isLaneBlocked === 'function' && isLaneBlocked(bb.p.x, bb.p.y, m.x, m.y, bb.p.team)) {
                            continue; // Path is blocked by an opponent
                        }

                        // 3. UP-ICE SCORING: Prioritize progress toward the ozone
                        const upIceScore = m.x * bb.forwardDir; 
                        if (upIceScore > maxUpIceScore) {
                            maxUpIceScore = upIceScore;
                            bestTeammate = m;
                        }
                    }
                }
            }
            if (bestTeammate) return { tx: bestTeammate.x, ty: bestTeammate.y, action: "pass", target: bestTeammate };
            return "FAILURE";
        }
    
    function getFormationZone(puckX, team) {
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const team0AttacksRight = (safeGoal1 < 500);
        let attackingRight = (team === 0) ? team0AttacksRight : !team0AttacksRight;
        const forwardDir = attackingRight ? 1 : -1;
        const RX_CENTER = 500;
        const D_LINE = RX_CENTER - (forwardDir * 110);
        const O_LINE = RX_CENTER + (forwardDir * 110);
        const D_DEEP = RX_CENTER - (forwardDir * 250);

        if (forwardDir === 1) { 
            if (puckX < D_DEEP) return 1; if (puckX < D_LINE) return 2; if (puckX < RX_CENTER) return 3;
            if (puckX < O_LINE) return 4; if (puckX < O_LINE + 150) return 5; return 6;
        } else { 
            if (puckX > D_DEEP) return 1; if (puckX > D_LINE) return 2; if (puckX > RX_CENTER) return 3;
            if (puckX > O_LINE) return 4; if (puckX > O_LINE - 150) return 5; return 6;
        }
    }
    function getSmartShootTarget(p, bb, laneWidth = 15, angleBuffer = 10) {
        const targetX = bb.enemyGoal;
        const targetY = (typeof RY !== 'undefined' ? RY : 300);
        
        // Pass the adjustable angleBuffer to the vision check
        if (canSeeNet(p, angleBuffer, laneWidth)) {
             return { tx: targetX, ty: targetY, action: "shoot" };
        }
        return null;
    }

    function findLeastGuardedInZone(p, bb) {
        let bestTeammate = null;
        let maxSafetyScore = -1;
        if (typeof players === 'undefined') return null;

        for (let m of players) {
            if (m.team === p.team && m.id !== p.id && m.type === 'skater') {
                
                // --- THE "WTF" GUARD: Forward Progress Only ---
                const progress = (m.x - p.x) * bb.forwardDir;
                if (progress < 30) continue; 

                // 1. Ozone Check
                const inOzone = (m.x - 500) * bb.forwardDir > 110; 
                if (!inOzone) continue;

                // 2. MOVEMENT PREDICTION
                const lead = (typeof predictLeadPass === 'function') ? predictLeadPass(p, m) : {x: m.x, y: m.y};
                if (!lead) continue;

                // 3. Future Lane Check
                if (typeof isLaneBlocked === 'function' && isLaneBlocked(p.x, p.y, lead.x, lead.y, p.team)) {
                    continue;
                }
                
                // Safety: Net Check
                if (typeof passIntersectsOwnNet === 'function' && passIntersectsOwnNet(p, lead.x, lead.y)) {
                    continue;
                }

                // 4. Future Pressure Check
                let minOppDist = 9999;
                for (let opp of players) {
                    if (opp.team !== p.team) {
                        const d = Math.hypot(lead.x - opp.x, lead.y - opp.y);
                        if (d < minOppDist) minOppDist = d;
                    }
                }

                // 5. Scoring
                if (minOppDist > maxSafetyScore) {
                    maxSafetyScore = minOppDist;
                    bestTeammate = { ...m, x: lead.x, y: lead.y };
                }
            }
        }
        return bestTeammate;
    }
function getPositionWithinLimits(p, bb, d) {
    const rinkTop = 170; // Physical Canvas Top
    const rinkBot = 430; // Physical Canvas Bottom
    
    const minOwn = Number(d.minDistOwnGoal || 0);
    const minOpp = Number(d.minDistOppGoal || 0);
    
    // --- PERSPECTIVE FLIP FIX ---
    // If forwardDir is 1 (Attacking Right), Left is Top (170).
    // If forwardDir is -1 (Attacking Left), Left is Bottom (430).
    const isAttackingRight = (bb.forwardDir === 1);
    const minLeftDist = isAttackingRight ? Number(d.minDistLeftBoard || 0) : Number(d.minDistRightBoard || 0);
    const minRightDist = isAttackingRight ? Number(d.minDistRightBoard || 0) : Number(d.minDistLeftBoard || 0);

    let moveX = p.x, moveY = p.y;

    // X-Axis Goal Distance Logic
    if (Math.abs(p.x - bb.myGoalX) < minOwn) { 
        moveX = bb.myGoalX + (bb.forwardDir * minOwn); 
    } else if (Math.abs(p.x - bb.enemyGoal) < minOpp) { 
        moveX = bb.enemyGoal - (bb.forwardDir * minOpp); 
    }
    
    // Y-Axis Board Logic (Now Team-Aware)
    // Check Top Board
    if (p.y - rinkTop < minLeftDist) { 
        moveY = rinkTop + minLeftDist; 
    } 
    // Check Bottom Board
    else if (rinkBot - p.y < minRightDist) { 
        moveY = rinkBot - minRightDist; 
    }

    return { tx: moveX, ty: moveY, action: "none" };
}
    function getAggressiveGapTarget(defender, carrier, goalX) {
        const IDEAL_GAP = 75; const MIN_DIST_FROM_NET = 80;
        const gx = goalX; const gy = (typeof RY!=='undefined'?RY:300);
        const target = carrier || {x:0, y:0};
        const dx = target.x - gx; const dy = target.y - gy;
        const distToCarrier = Math.max(1, Math.hypot(dx, dy)); // SAFETY: No Zero Div
        let tx, ty;
        if (distToCarrier < MIN_DIST_FROM_NET + 10) {
            const aggressiveGap = Math.max(35, distToCarrier - MIN_DIST_FROM_NET);
            const t = (distToCarrier - aggressiveGap) / distToCarrier;
            tx = gx + t * dx; ty = gy + t * dy;
        } else {
            const t = Math.max(0, (distToCarrier - IDEAL_GAP) / distToCarrier);
            tx = gx + t * dx; ty = gy + t * dy;
        }
        if (!isFinite(tx) || !isFinite(ty)) return { tx: 500, ty: 300, action: "none" }; // SAFETY
        const distToTarget = Math.hypot(tx - defender.x, ty - defender.y);
        const myDistToNet = Math.hypot(defender.x - gx, defender.y - gy);
        const isBeat = distToCarrier < myDistToNet;
        if (isBeat || distToTarget > 120) { return { tx: tx, ty: ty, action: "none" }; }
        return { tx: tx, ty: ty, action: "none" }; 
    }
    function checkTeammatesOffside(p) {
        const forwardDir = (p.team === 0 ? 1 : -1);
        const blueLineX = 500 + (forwardDir * 110);
        for(const m of players) {
            if(m.team === p.team && m.id !== p.id && m.type === 'skater') {
                if((m.x - blueLineX) * forwardDir > 5) return true;
            }
        }
        return false;
    }
    function evadePressure(bb) {
        let escX = 0, escY = 0, count = 0;
        for(const o of players) {
            if(o.team !== bb.p.team && Math.hypot(bb.p.x - o.x, bb.p.y - o.y) < 100) {
                escX += (bb.p.x - o.x); escY += (bb.p.y - o.y); count++;
            }
        }
        if(count===0) return {tx: 500, ty: 300, action:'none'}; // SAFETY
        return {tx: bb.p.x + escX, ty: bb.p.y + escY, action:'none'};
    }


    function getDynamicCarry(p, bb) {
    const FORWARD_DIST = 120;
    const EVADE_RADIUS = 100;
    
    // 1. Initial Forward Intent (The Football Receiver route)
    let tx = p.x + (bb.forwardDir * FORWARD_DIST);
    let ty = p.y;

    // 2. Sum up the "Push" from nearby enemies
    let pushX = 0;
    let pushY = 0;
    let count = 0;

    for (const o of players) {
        if (o.team !== p.team) {
            const dist = Math.hypot(p.x - o.x, p.y - o.y);
            if (dist < EVADE_RADIUS) {
                // The closer they are, the harder they "push" the path away
                const force = (EVADE_RADIUS - dist) / EVADE_RADIUS;
                pushX += (p.x - o.x) * force;
                pushY += (p.y - o.y) * force;
                count++;
            }
        }
    }

    // 3. Blend the forward intent with the evasion push
    if (count > 0) {
        tx += pushX * 1.5; // Multiply push to make the weave more noticeable
        ty += pushY * 1.5;
    }

    // 4. Stay on the Rink
    ty = Math.max(170, Math.min(430, ty));

    return { tx: tx, ty: ty, action: "none" };
    }

    function hoverDynamicLine(bb) {
        const defendingRight = (bb.myGoalX > 500);
        let deepest = null;
        for (const pl of players) {
            if (pl.type !== "skater" || pl.id === bb.p.id) continue;
            if (!deepest) { deepest = pl; continue; }
            if (defendingRight) { if (pl.x > deepest.x) deepest = pl; }
            else { if (pl.x < deepest.x) deepest = pl; }
        }
        if (!deepest) return { tx: bb.p.x + 1, ty: bb.p.y, action: "none" };
        const gap = 80;
        return { tx: (defendingRight ? deepest.x + gap : deepest.x - gap), ty: (typeof RY!=='undefined'?RY:300), action: "none" };
    }
    function clearPuckDefensive(p) {
        const forwardDir = (p.team === 0 ? 1 : -1);
        const targetX = p.x + forwardDir * 200;
        const Y_HIGH = (typeof RY!=='undefined'?RY:300) - 150, Y_LOW = (typeof RY!=='undefined'?RY:300) + 150;
        return { tx: targetX, ty: (Math.abs(p.y - Y_HIGH) < Math.abs(p.y - Y_LOW) ? Y_HIGH : Y_LOW), action: "shoot" };
    }

    function makeBB(p) {
        const safeRX = (typeof RX !== 'undefined') ? RX : 500;
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const safeGoal2 = (typeof goal2 !== 'undefined') ? goal2 : 825;
        const myGoalX = (p.team === 0 ? safeGoal1 : safeGoal2);
        const enemyGoal = (p.team === 0 ? safeGoal2 : safeGoal1);
        const forwardDir = (enemyGoal > myGoalX ? 1 : -1);
        const carrier = (typeof getPlayerById === 'function' && typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null;

        return {
            p: p, myGoalX, enemyGoal, forwardDir, safeRX,
            hasPuck: (typeof puck !== 'undefined' && puck.ownerId === p.id),
            loosePuck: (typeof puck !== 'undefined' && puck.ownerId === null),
            oppHasPuck: (carrier && carrier.team !== p.team),
            teamHasPuck: (carrier && carrier.team === p.team),
            inShotRange: (Math.hypot(enemyGoal - p.x, (typeof RY !== 'undefined' ? RY : 300) - p.y) < 250),
            puckInDefZone: (forwardDir === 1 ? puck.x < safeRX - 60 : puck.x > safeRX + 60),
            puckInOffZone: (forwardDir === 1 ? puck.x > safeRX + 60 : puck.x < safeRX - 60),
            puckInNeuZone: (Math.abs(puck.x - safeRX) <= 60),
            interceptPoint: predictPuckIntersection(p),
            carryTarget: null, passTarget: null
        };
    }

    // --- TREES ---
    const TREE_C = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => {let d=120||250; return Math.hypot(bb.enemyGoal-bb.p.x, (typeof RY!=='undefined'?RY:300)-bb.p.y) < d;}),
                new ActionNode(bb => getSmartShootTarget(bb.p, bb, 15, 10), "smartshoot")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => { try { const t = (typeof findLeastGuardedInZone === 'function' ? findLeastGuardedInZone(bb.p, bb) : null); if(t){ return {tx:t.x, ty:t.y, action:"pass", target:t}; } return "FAILURE"; } catch(e){return "FAILURE";} }, "OZONE R PASS")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => ({ tx: bb.enemyGoal - (bb.forwardDir * 40), ty: (typeof RY !== 'undefined' ? RY : 300), action: "none" }), "Drive Net")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { const t = (typeof findQualifiedBreakout === 'function' ? findQualifiedBreakout(bb.p, bb, {safety:50,fwd:300,back:30}) : null); if(t){bb.passTarget=t; return true;} return false; } catch(e){return false;} }),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 40), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 20),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 25),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.teamHasPuck),
                new ActionNode(bb => ({ tx: bb.enemyGoal - (bb.forwardDir * 40), ty: (typeof RY !== 'undefined' ? RY : 300), action: "none" }), "Drive Net")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.teamHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"350","minDistOppGoal":"250","minDistLeftBoard":"150","minDistRightBoard":"150"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===1 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"150","minDistOppGoal":"440","minDistLeftBoard":"150","minDistRightBoard":"150"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===2 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"200","minDistOppGoal":"390","minDistLeftBoard":"150","minDistRightBoard":"150"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===3 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"250","minDistOppGoal":"340","minDistLeftBoard":"150","minDistRightBoard":"150"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===4 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"300","minDistOppGoal":"450","minDistLeftBoard":"150","minDistRightBoard":"150"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===5 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"440","minDistOppGoal":"0","minDistLeftBoard":"50","minDistRightBoard":"50"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===6 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"440","minDistOppGoal":"0","minDistLeftBoard":"50","minDistRightBoard":"50"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")])]);
    const TREE_LW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => {let d=120||250; return Math.hypot(bb.enemyGoal-bb.p.x, (typeof RY!=='undefined'?RY:300)-bb.p.y) < d;}),
                new ActionNode(bb => getSmartShootTarget(bb.p, bb, 15, 10), "smartshoot")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => { try { const t = (typeof findLeastGuardedInZone === 'function' ? findLeastGuardedInZone(bb.p, bb) : null); if(t){ return {tx:t.x, ty:t.y, action:"pass", target:t}; } return "FAILURE"; } catch(e){return "FAILURE";} }, "OZONE R PASS")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { const t = (typeof findQualifiedBreakout === 'function' ? findQualifiedBreakout(bb.p, bb, {safety:50,fwd:300,back:30}) : null); if(t){bb.passTarget=t; return true;} return false; } catch(e){return false;} }),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 40), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 20),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 25),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => ({ tx: bb.enemyGoal - (bb.forwardDir * 40), ty: (typeof RY !== 'undefined' ? RY : 300), action: "none" }), "Drive Net")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.teamHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"600","minDistOppGoal":"0","minDistLeftBoard":"0","minDistRightBoard":"200"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.teamHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"350","minDistOppGoal":"250","minDistLeftBoard":"0","minDistRightBoard":"300"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"150","minDistOppGoal":"450","minDistLeftBoard":"0","minDistRightBoard":"250"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")])]);
    const TREE_RW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => {let d=120||250; return Math.hypot(bb.enemyGoal-bb.p.x, (typeof RY!=='undefined'?RY:300)-bb.p.y) < d;}),
                new ActionNode(bb => getSmartShootTarget(bb.p, bb, 15, 10), "smartshoot")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => { try { const t = (typeof findLeastGuardedInZone === 'function' ? findLeastGuardedInZone(bb.p, bb) : null); if(t){ return {tx:t.x, ty:t.y, action:"pass", target:t}; } return "FAILURE"; } catch(e){return "FAILURE";} }, "OZONE R PASS")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { const t = (typeof findQualifiedBreakout === 'function' ? findQualifiedBreakout(bb.p, bb, {safety:50,fwd:300,back:30}) : null); if(t){bb.passTarget=t; return true;} return false; } catch(e){return false;} }),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 40), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 20),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 25),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => ({ tx: bb.enemyGoal - (bb.forwardDir * 40), ty: (typeof RY !== 'undefined' ? RY : 300), action: "none" }), "Drive Net")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.teamHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"600","minDistOppGoal":"0","minDistLeftBoard":"200","minDistRightBoard":"0"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.teamHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"350","minDistOppGoal":"250","minDistLeftBoard":"300","minDistRightBoard":"0"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"150","minDistOppGoal":"450","minDistLeftBoard":"250","minDistRightBoard":"0"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")])]);
    const TREE_LD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => {let d=325||250; return Math.hypot(bb.enemyGoal-bb.p.x, (typeof RY!=='undefined'?RY:300)-bb.p.y) < d;}),
                new ActionNode(bb => getSmartShootTarget(bb.p, bb, 15, 10), "smartshoot")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { const t = (typeof findQualifiedBreakout === 'function' ? findQualifiedBreakout(bb.p, bb, {safety:50,fwd:300,back:30}) : null); if(t){bb.passTarget=t; return true;} return false; } catch(e){return false;} }),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 40), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(20>0 && myD<20) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 20),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { try { return (typeof evadePressure === 'function' ? evadePressure(bb) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Evade")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => ({ tx: bb.enemyGoal - (bb.forwardDir * 40), ty: (typeof RY !== 'undefined' ? RY : 300), action: "none" }), "Drive Net")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(50>0 && myD<50) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"220","minDistOppGoal":"250","minDistLeftBoard":"50","minDistRightBoard":"150"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"200","minDistOppGoal":"400","minDistLeftBoard":"100","minDistRightBoard":"200"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ActionNode(bb => { try { return (typeof getAggressiveGapTarget === 'function' ? getAggressiveGapTarget(bb.p, (typeof getPuckCarrier === 'function' ? getPuckCarrier() : puck), bb.myGoalX) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} })]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===1 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"30","minDistOppGoal":"600","minDistLeftBoard":"140","minDistRightBoard":"170"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===2 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"40","minDistOppGoal":"550","minDistLeftBoard":"120","minDistRightBoard":"170"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===6 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"450","minDistOppGoal":"200","minDistLeftBoard":"50","minDistRightBoard":"200"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")])]);
    const TREE_RD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => {let d=325||250; return Math.hypot(bb.enemyGoal-bb.p.x, (typeof RY!=='undefined'?RY:300)-bb.p.y) < d;}),
                new ActionNode(bb => getSmartShootTarget(bb.p, bb, 15, 10), "smartshoot")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { const t = (typeof findQualifiedBreakout === 'function' ? findQualifiedBreakout(bb.p, bb, {safety:50,fwd:300,back:30}) : null); if(t){bb.passTarget=t; return true;} return false; } catch(e){return false;} }),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 40), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(20>0 && myD<20) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => (bb.p.carrier_patience_dist || 9999) < 20),
                new ActionNode(bb => intel_test(bb), "Intel Scan"),
                new ActionNode(bb => carrier_intel(bb, 1), "Carrier Intel"),
                new ActionNode(bb => pass_test(bb, 50), "Pass Test")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { try { return (typeof evadePressure === 'function' ? evadePressure(bb) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Evade")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInDefZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; }, "Carry")]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => ({ tx: bb.enemyGoal - (bb.forwardDir * 40), ty: (typeof RY !== 'undefined' ? RY : 300), action: "none" }), "Drive Net")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(50>0 && myD<50) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"220","minDistOppGoal":"250","minDistLeftBoard":"150","minDistRightBoard":"50"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"200","minDistOppGoal":"400","minDistLeftBoard":"200","minDistRightBoard":"100"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => {let myD=Math.hypot(bb.p.x-puck.x,bb.p.y-puck.y); if(0>0 && myD<0) return true; let c=null,d=9999; for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept === 'function') ? getPuckIntercept(bb.p, 1.5) : { x: puck.x, y: puck.y }; return { tx: t.x, ty: t.y, action: "none" }; } catch(e) { return { tx: bb.p.x, ty: bb.p.y, action: "none" }; } }, "Intercept")]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ActionNode(bb => { try { return (typeof getAggressiveGapTarget === 'function' ? getAggressiveGapTarget(bb.p, (typeof getPuckCarrier === 'function' ? getPuckCarrier() : puck), bb.myGoalX) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} })]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===1 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"30","minDistOppGoal":"600","minDistLeftBoard":"170","minDistRightBoard":"140"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===2 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"40","minDistOppGoal":"550","minDistLeftBoard":"170","minDistRightBoard":"120"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof getFormationZone==='function' ? getFormationZone(puck.x, bb.p.team)===6 : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { return (typeof getPositionWithinLimits === 'function' ? getPositionWithinLimits(bb.p, bb, {"type":"actGoToPosition","cat":"act","minDistOwnGoal":"450","minDistOppGoal":"200","minDistLeftBoard":"200","minDistRightBoard":"50"}) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} }, "Go To Pos")])]);

    // --- MAIN BRAIN (ANTI-VANISH SHIELD) ---
function think(p) {
        try {
            const bb = makeBB(p);
            let result = null;

            // Execute role-based trees
            if (p.role === "C") result = TREE_C ? TREE_C.tick(bb) : null;
            else if (p.role === "LW") result = TREE_LW ? TREE_LW.tick(bb) : null;
            else if (p.role === "RW") result = TREE_RW ? TREE_RW.tick(bb) : null;
            else if (p.role === "LD") result = TREE_LD ? TREE_LD.tick(bb) : null;
            else if (p.role === "RD") result = TREE_RD ? TREE_RD.tick(bb) : null;

        // --- THE SHIELD (MATHEMATICALLY SAFE) ---
            const isTargetObject = (result && typeof result === "object" && 'tx' in result);

            if (!isTargetObject) {
                // If the logic fails, point them 1 pixel ahead
                // This prevents the Division by Zero if they have the puck.
                return { tx: p.x + 1, ty: p.y, action: "none" }; 
            }

            return result;
        } catch (e) {
            // Safety fallback if a function like getDynamicCarry crashes
            return { tx: p.x + 1, ty: p.y, action: "none" };
        }
    }

    if (typeof registerStrategy === "function") {
        registerStrategy(
            STRATEGY_ID,
            "Edmonton",
            "Oilers",
            "EDM",
            think,
            { main: "#00205b", secondary: "#cf4520" }
        );
    }
})();
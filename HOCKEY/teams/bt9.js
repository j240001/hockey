// ==========================================
// STRATEGY: Hand Crafted (EDM)
// Generated by Builder V16
// ==========================================
(function() {
    const STRATEGY_ID = "BT_" + "EDM_" + Math.floor(Math.random()*99999);
    
    // --- ENGINE ---
    class Node{constructor(){} tick(bb){return false;}}
    class ConditionNode extends Node{constructor(fn){super();this.fn=fn;} tick(bb){return this.fn(bb)?"SUCCESS":"FAILURE";}}
    class ActionNode extends Node{constructor(fn){super();this.fn=fn;} tick(bb){return this.fn(bb);}}
    class SequenceNode extends Node{constructor(c){super();this.children=c;} tick(bb){for(let n of this.children){let r=n.tick(bb);if(r!=="SUCCESS")return r;}return"SUCCESS";}}
    class SelectorNode extends Node{constructor(c){super();this.children=c;} tick(bb){for(let n of this.children){let r=n.tick(bb);if(r!=="FAILURE")return r;}return"FAILURE";}}

    // --- HELPERS ---
    function predictPuckIntersection(p) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x, y: p.y };
        return { x: puck.x + puck.vx * 10, y: puck.y + puck.vy * 10 };
    }

    function makeBB(p) {
        const safeRX = (typeof RX !== 'undefined') ? RX : 500;
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const safeGoal2 = (typeof goal2 !== 'undefined') ? goal2 : 825;
        const myGoalX = (p.team === 0 ? safeGoal1 : safeGoal2);
        const enemyGoal = (p.team === 0 ? safeGoal2 : safeGoal1);
        const forwardDir = (enemyGoal > myGoalX ? 1 : -1);
        const carrier = getPlayerById(puck.ownerId);

        return {
            p, myGoalX, enemyGoal, forwardDir, safeRX,
            hasPuck: (puck.ownerId === p.id),
            loosePuck: (puck.ownerId === null),
            oppHasPuck: (carrier && carrier.team !== p.team),
            teamHasPuck: (carrier && carrier.team === p.team),
            inShotRange: (Math.hypot(enemyGoal - p.x, RY - p.y) < 200),
            puckInDefZone: (forwardDir === 1 ? puck.x < safeRX - 60 : puck.x > safeRX + 60),
            puckInOffZone: (forwardDir === 1 ? puck.x > safeRX + 60 : puck.x < safeRX - 60),
            puckInNeuZone: (Math.abs(puck.x - safeRX) <= 60),
            interceptPoint: predictPuckIntersection(p),
            carryTarget: null, passTarget: null
        };
    }

    // --- CONDITIONS ---
    const condHasPuck = new ConditionNode(bb => bb.hasPuck);
    const condLoosePuck = new ConditionNode(bb => bb.loosePuck);
    const condInShotRange = new ConditionNode(bb => bb.inShotRange);
    const condTeamHasPuck = new ConditionNode(bb => bb.teamHasPuck);
    const condOppHasPuck = new ConditionNode(bb => bb.oppHasPuck);
    const condPuckInDefZone = new ConditionNode(bb => bb.puckInDefZone);
    const condPuckInOffZone = new ConditionNode(bb => bb.puckInOffZone);
    const condPuckInNeuZone = new ConditionNode(bb => bb.puckInNeuZone);
    const condTeammatesOffside = new ConditionNode(bb => checkTeammatesOffside(bb.p));
    
    const condIsPressured = new ConditionNode(bb => {
        let pressureCount = 0;
        for (const o of players) {
            if (o.team !== bb.p.team && Math.hypot(o.x - bb.p.x, o.y - bb.p.y) < 80) pressureCount++;
        }
        return pressureCount >= 2;
    });

    const condAmIClosest = new ConditionNode(bb => {
        let c = null, d = 9999;
        for (let m of players) {
            if (m.team === bb.p.team) {
                let dist = Math.hypot(m.x - puck.x, m.y - puck.y);
                if (dist < d) { d = dist; c = m; }
            }
        }
        return c && c.id === bb.p.id;
    });

    const condForwardLaneClear = new ConditionNode(bb => {
        bb.carryTarget = { x: bb.p.x + bb.forwardDir * 100, y: bb.p.y };
        return !isLaneBlocked(bb.p.x, bb.p.y, bb.carryTarget.x, bb.carryTarget.y, bb.p.team);
    });

    const condHasBreakoutPass = new ConditionNode(bb => {
        for (let m of players) {
            if (m.team === bb.p.team && m.id !== bb.p.id && m.type === 'skater' && (m.x - bb.p.x) * bb.forwardDir > 0) {
                if (!isLaneBlocked(bb.p.x, bb.p.y, m.x, m.y, bb.p.team)) {
                    bb.passTarget = m;
                    return true;
                }
            }
        }
        return false;
    });

    // --- ACTIONS ---
    const actShoot = new ActionNode(bb => ({ tx: bb.enemyGoal, ty: RY, action: "shoot" }));
    const actIdle = new ActionNode(bb => ({ tx: bb.p.x, ty: bb.p.y, action: "none" }));
    const actChill = new ActionNode(bb => ({ tx: bb.p.x, ty: bb.p.y, action: "none" }));
    
    const actDriveNet = new ActionNode(bb => ({ 
        tx: bb.enemyGoal - (bb.forwardDir * 40), 
        ty: RY, 
        action: "none" 
    }));

    const actHoverBlueLine = new ActionNode(bb => {
        let yOff = 0;
        if (bb.p.role === 'LW' || bb.p.role === 'LD') yOff = -100;
        if (bb.p.role === 'RW' || bb.p.role === 'RD') yOff = 100;
        return { tx: (bb.forwardDir === 1 ? bb.safeRX + 60 : bb.safeRX - 60), ty: RY + yOff, action: "none" };
    });

    const actTagUp_T1 = new ActionNode(bb => ({ tx: bb.safeRX - bb.forwardDir * 50, ty: RY, action: "none" }));

    const actSmartIntercept = new ActionNode(bb => {
        const target = getPuckIntercept(bb.p);
        return { tx: target.x, ty: target.y, action: "none" };
    });

    const actExecuteCarry = new ActionNode(bb => {
        if (bb.carryTarget) return { tx: bb.carryTarget.x, ty: bb.carryTarget.y, action: "none" };
        let yOff = 0;
        if (bb.p.role === 'LW' || bb.p.role === 'LD') yOff = -120;
        if (bb.p.role === 'RW' || bb.p.role === 'RD') yOff = 120;
        return { tx: bb.enemyGoal, ty: RY + yOff, action: "none" };
    });

    const actExecutePass = new ActionNode(bb => {
        if (bb.passTarget) return { tx: bb.passTarget.x, ty: bb.passTarget.y, action: "pass", target: bb.passTarget };
        return { tx: bb.enemyGoal, ty: RY, action: "none" };
    });

    const actDefendHome = new ActionNode(bb => {
        let yOff = 0;
        if (bb.p.role === 'LD' || bb.p.role === 'LW') yOff = -60;
        if (bb.p.role === 'RD' || bb.p.role === 'RW') yOff = 60;
        return { tx: bb.myGoalX + (bb.forwardDir * 120), ty: RY + yOff, action: 'none' };
    });

    // --- TREES ---
    const TREE_C = 
        new SelectorNode([
            new SequenceNode([
                new ConditionNode(bb => checkTeammatesOffside(bb.p)),
                actTagUp_T1
            ]),
            new SequenceNode([
                condHasPuck,
                new SelectorNode([
                    new SequenceNode([
                        condPuckInDefZone,
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new SequenceNode([
                        condInShotRange,
                        actShoot
                    ]),
                    actDriveNet
                ])
            ]),
            actSmartIntercept
        ]);

    const TREE_LW = 
        new SelectorNode([
            new SequenceNode([
                new ConditionNode(bb => checkTeammatesOffside(bb.p)),
                actTagUp_T1
            ]),
            new SequenceNode([
                condHasPuck,
                new SelectorNode([
                    new SequenceNode([
                        condPuckInDefZone,
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new SequenceNode([
                        condInShotRange,
                        actShoot
                    ]),
                    actDriveNet
                ])
            ]),
            new SequenceNode([
                condPuckInDefZone,
                actHoverBlueLine
            ]),
            actSmartIntercept
        ]);

    const TREE_RW = 
        new SelectorNode([
            new SequenceNode([
                new ConditionNode(bb => checkTeammatesOffside(bb.p)),
                actTagUp_T1
            ]),
            new SequenceNode([
                condHasPuck,
                new SelectorNode([
                    new SequenceNode([
                        condPuckInDefZone,
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new SequenceNode([
                        condInShotRange,
                        actShoot
                    ]),
                    actDriveNet
                ])
            ]),
            new SequenceNode([
                condPuckInDefZone,
                actHoverBlueLine
            ]),
            actSmartIntercept
        ]);

    const TREE_LD = 
        new SelectorNode([
            new SequenceNode([
                new ConditionNode(bb => checkTeammatesOffside(bb.p)),
                actTagUp_T1
            ]),
            new SequenceNode([
                condHasPuck,
                new SelectorNode([
                    new SequenceNode([
                        condInShotRange,
                        actShoot
                    ]),
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    actExecuteCarry
                ])
            ]),
            new SequenceNode([
                condOppHasPuck,
                actDefendHome
            ]),
            actHoverBlueLine
        ]);

    const TREE_RD = 
        new SelectorNode([
            new SequenceNode([
                new ConditionNode(bb => checkTeammatesOffside(bb.p)),
                actTagUp_T1
            ]),
            new SequenceNode([
                condHasPuck,
                new SelectorNode([
                    new SequenceNode([
                        condInShotRange,
                        actShoot
                    ]),
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    actExecuteCarry
                ])
            ]),
            new SequenceNode([
                condOppHasPuck,
                actDefendHome
            ]),
            actHoverBlueLine
        ]);

    // --- MAIN BRAIN ---
    function think(p) {
        const bb = makeBB(p);
        let result = null;

        switch(p.role) {
            case "C":  result = TREE_C.tick(bb);  break;
            case "LW": result = TREE_LW.tick(bb); break;
            case "RW": result = TREE_RW.tick(bb); break;
            case "LD": result = TREE_LD.tick(bb); break;
            case "RD": result = TREE_RD.tick(bb); break;
            default:   result = TREE_C.tick(bb);  break; 
        }

        if (!result || typeof result === "string" || isNaN(result.tx)) {
            return { tx: p.x, ty: p.y, action: "none" };
        }
        return result;
    }

    if (typeof registerStrategy === "function") {
        registerStrategy(
            STRATEGY_ID,
            "Hand Crafted",
            "Oilers",
            "EDM",
            think,
            { main: "#120099", secondary: "#ff5900" }
        );
    }
})();

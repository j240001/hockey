// Ottawa (OTT) - Generated by Builder V30 (Safe Mode)
(function() {
    const STRATEGY_ID = "BT_" + "OTT_" + Math.floor(Math.random() * 99999);

    // --- ENGINE ---
    class Node { constructor() {} tick(bb) { return false; } }
    class ConditionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb) ? "SUCCESS" : "FAILURE"; } }
    class ActionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb); } }
    class SequenceNode extends Node { constructor(c) { super(); this.children = c; } tick(bb) { for (let n of this.children) { let r = n.tick(bb); if (r !== "SUCCESS") return r; } return "SUCCESS"; } }
    class SelectorNode extends Node { constructor(c) { super(); this.children = c; } tick(bb) { for (let n of this.children) { let r = n.tick(bb); if (r !== "FAILURE") return r; } return "FAILURE"; } }


    // --- CORE HELPERS (Math & Vision) ---
    function clamp(v, lo, hi) { return v < lo ? lo : (v > hi ? hi : v); }
    function normalizeAngle(a) { while (a <= -Math.PI) a += 2 * Math.PI; while (a > Math.PI) a -= 2 * Math.PI; return a; }
    function pointLineDistance(x1, y1, x2, y2, px, py) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A*C + B*D, lenSq = C*C + D*D;
        if (lenSq < 0.001) return Math.hypot(px - x1, py - y1); // Avoid Zero Div
        const t = Math.max(0, Math.min(1, dot / lenSq));
        return Math.hypot(px - (x1 + t * C), py - (y1 + t * D));
    }
    function getPlayerById(id) { return (typeof players !== 'undefined') ? players.find(p => p.id === id) : null; }
    function getPuckCarrier() { return (typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null; }
    function isLaneBlocked(x1, y1, x2, y2, team) {
        if (typeof players === 'undefined') return false;
        for (const o of players) {
            if (o.team === team) continue;
            if (pointLineDistance(x1, y1, x2, y2, o.x, o.y) < 18) return true;
        }
        return false;
    }
    function predictPuckIntersection(p) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x, y: p.y };
        return { x: puck.x + puck.vx * 10, y: puck.y + puck.vy * 10 };
    }
    function getPuckIntercept(p) {
        if (typeof puck === 'undefined') return {x: p.x, y: p.y};
        const dist = Math.hypot(puck.x - p.x, puck.y - p.y);
        const frames = dist / 4.0; 
        let tx = puck.x + puck.vx * frames;
        let ty = puck.y + puck.vy * frames;
        tx = Math.max(120, Math.min(880, tx));
        ty = Math.max(170, Math.min(430, ty));
        return { x: tx, y: ty };
    }
    
    function findSmartPass(p, bb) {
        let best = null, bestScore = -999;
        const skaters = players.filter(m => m.team === p.team && m.id !== p.id && m.type === "skater");
        for (const mate of skaters) {
            if (isLaneBlocked(p.x, p.y, mate.x, mate.y, p.team)) continue;
            let score = -Math.hypot(mate.x - bb.enemyGoal, mate.y - (typeof RY!=='undefined'?RY:300));
            for (const o of players) {
                if (o.team !== p.team && Math.hypot(o.x - mate.x, o.y - mate.y) < 60) score -= 1000;
            }
            if (score > bestScore) { bestScore = score; best = mate; }
        }
        return best;
    }
    function condWeightedPassCheck(bb, bias, fear, vision) {
        // --- TUNING SECTION (Adjust these to change Team Physics) ---
        const FWD_BONUS = 3.0;          // Points added for moving closer to enemy net
        const BWD_PENALTY = -6.0;       // Points subtracted for moving away from enemy net
        const BLUE_LINE_PENALTY = -20.0;// Penalty for passing out of the Offensive Zone
        const MIN_PASS_DIST = 50;       // Minimum pixel distance (Safety)
        // -----------------------------------------------------------

        const p = bb.p;
        
        // 1. Calculate Pressure (0.0 to 2.0)
        let enemyPressure = 0;
        if (typeof players !== 'undefined') {
            for (const o of players) {
                if (o.team === p.team) continue;
                const d = Math.hypot(o.x - p.x, o.y - p.y);
                if (d < 60) enemyPressure += 1.0; else if (d < 120) enemyPressure += 0.5;
            }
        }
        enemyPressure = Math.min(2.0, enemyPressure);

        // 2. Evaluate Teammates
        let bestTeammateScore = -999; 
        let bestTarget = null;
        const teammates = (typeof players !== 'undefined') ? players.filter(m => m.team === p.team && m.id !== p.id && m.type !== 'goalie') : [];
        
        for (const mate of teammates) {
            const d = Math.hypot(mate.x - p.x, mate.y - p.y);
            
            // Safety Check
            if (d < MIN_PASS_DIST) continue; 

            let distScore = (d > 100 && d < 400) ? 1.0 : 0.2;
            let laneBlocked = isLaneBlocked(p.x, p.y, mate.x, mate.y, p.team);
            
            if (!laneBlocked) {
                // DISTANCE LOGIC
                const myDist = Math.hypot(p.x - bb.enemyGoal, p.y - 300);
                const mateDist = Math.hypot(mate.x - bb.enemyGoal, mate.y - 300);
                
                // PROGRESS SCORE (Uses your Tuning Variables)
                let progressScore = (myDist - mateDist) > 0 ? FWD_BONUS : BWD_PENALTY;

                // BLUE LINE LOGIC
                const myRelX = (p.x - bb.safeRX) * bb.forwardDir;     
                const mateRelX = (mate.x - bb.safeRX) * bb.forwardDir;
                // If I am deep (25px past center) and mate is not...
                if (myRelX > 25 && mateRelX < 25) {
                    progressScore += BLUE_LINE_PENALTY; 
                }

                const total = distScore + progressScore;
                if (total > bestTeammateScore) { bestTeammateScore = total; bestTarget = mate; }
            }
        }

        // 3. Final Score Calculation
        // Formula: Bias + (Pressure * Fear) + (BestOption * Vision)
        let passScore = (bias * 1.0) + (enemyPressure * fear * 1.5) + (bestTeammateScore * vision * 2.0);
        let carryScore = (100 - bias);
        
        // Open Ice Carry Bonus
        let closestEnemy = 999;
        if (typeof players !== 'undefined') { for(const o of players) { if(o.team !== p.team) closestEnemy = Math.min(closestEnemy, Math.hypot(o.x-p.x, o.y-p.y)); } }
        if (closestEnemy > 150) carryScore += 50;

        // Threshold to Pass
        // Note: bestTeammateScore must be > -10 to prevent passing to a terrible option just because carryScore is low
        if (passScore > carryScore && bestTarget !== null && bestTeammateScore > -10.0) { 
            bb.passTarget = bestTarget; 
            return true; 
        }
        return false;
    }
    function getAggressiveGapTarget(defender, carrier, goalX) {
        const IDEAL_GAP = 75; const MIN_DIST_FROM_NET = 80;
        const gx = goalX; const gy = (typeof RY!=='undefined'?RY:300);
        const target = carrier || {x:0, y:0};
        const dx = target.x - gx; const dy = target.y - gy;
        const distToCarrier = Math.max(1, Math.hypot(dx, dy)); // SAFETY: No Zero Div
        let tx, ty;
        if (distToCarrier < MIN_DIST_FROM_NET + 10) {
            const aggressiveGap = Math.max(35, distToCarrier - MIN_DIST_FROM_NET);
            const t = (distToCarrier - aggressiveGap) / distToCarrier;
            tx = gx + t * dx; ty = gy + t * dy;
        } else {
            const t = Math.max(0, (distToCarrier - IDEAL_GAP) / distToCarrier);
            tx = gx + t * dx; ty = gy + t * dy;
        }
        if (!isFinite(tx) || !isFinite(ty)) return { tx: 500, ty: 300, action: "none" }; // SAFETY
        const distToTarget = Math.hypot(tx - defender.x, ty - defender.y);
        const myDistToNet = Math.hypot(defender.x - gx, defender.y - gy);
        const isBeat = distToCarrier < myDistToNet;
        if (isBeat || distToTarget > 120) { return { tx: tx, ty: ty, action: "none" }; }
        return { tx: tx, ty: ty, action: "none" }; 
    }

    function makeBB(p) {
        const safeRX = (typeof RX !== 'undefined') ? RX : 500;
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const safeGoal2 = (typeof goal2 !== 'undefined') ? goal2 : 825;
        const myGoalX = (p.team === 0 ? safeGoal1 : safeGoal2);
        const enemyGoal = (p.team === 0 ? safeGoal2 : safeGoal1);
        const forwardDir = (enemyGoal > myGoalX ? 1 : -1);
        const carrier = (typeof getPlayerById === 'function' && typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null;

        return {
            p, myGoalX, enemyGoal, forwardDir, safeRX,
            hasPuck: (typeof puck !== 'undefined' && puck.ownerId === p.id),
            loosePuck: (typeof puck !== 'undefined' && puck.ownerId === null),
            oppHasPuck: (carrier && carrier.team !== p.team),
            teamHasPuck: (carrier && carrier.team === p.team),
            inShotRange: (Math.hypot(enemyGoal - p.x, (typeof RY !== 'undefined' ? RY : 300) - p.y) < 200),
            puckInDefZone: (forwardDir === 1 ? puck.x < safeRX - 60 : puck.x > safeRX + 60),
            puckInOffZone: (forwardDir === 1 ? puck.x > safeRX + 60 : puck.x < safeRX - 60),
            puckInNeuZone: (Math.abs(puck.x - safeRX) <= 60),
            interceptPoint: predictPuckIntersection(p),
            carryTarget: null, passTarget: null
        };
    }

    // --- TREES ---
    const TREE_C = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new SelectorNode([                    new SequenceNode([                        new ConditionNode(bb => bb.inShotRange),
                        new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
                    new SequenceNode([                        new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 10, 80, 95) : false); } catch(e){return false;} }),
                        new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
                    new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })])]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { try { return (typeof getAggressiveGapTarget === 'function' ? getAggressiveGapTarget(bb.p, (typeof getPuckCarrier === 'function' ? getPuckCarrier() : puck), bb.myGoalX) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_LW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new SelectorNode([                    new SequenceNode([                        new ConditionNode(bb => bb.inShotRange),
                        new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
                    new SequenceNode([                        new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 20, 80, 90) : false); } catch(e){return false;} }),
                        new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })])])]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -50), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_RW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new SelectorNode([                    new SequenceNode([                        new ConditionNode(bb => bb.inShotRange),
                        new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
                    new SequenceNode([                        new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 20, 80, 90) : false); } catch(e){return false;} }),
                        new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })])])]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -50), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_LD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { let yOff=(bb.p.role==='LD'||bb.p.role==='LW')?-60:60; return {tx:bb.myGoalX+(bb.forwardDir*120),ty:(typeof RY !== 'undefined' ? RY : 300)+yOff,action:'none'}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_RD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { let yOff=(bb.p.role==='LD'||bb.p.role==='LW')?-60:60; return {tx:bb.myGoalX+(bb.forwardDir*120),ty:(typeof RY !== 'undefined' ? RY : 300)+yOff,action:'none'}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);

    // --- MAIN BRAIN (ANTI-VANISH SHIELD) ---
    function think(p) {
        try {
            const bb = makeBB(p);
            let result = null;

            if (p.role === "C") result = TREE_C ? TREE_C.tick(bb) : null;
            else if (p.role === "LW") result = TREE_LW ? TREE_LW.tick(bb) : null;
            else if (p.role === "RW") result = TREE_RW ? TREE_RW.tick(bb) : null;
            else if (p.role === "LD") result = TREE_LD ? TREE_LD.tick(bb) : null;
            else if (p.role === "RD") result = TREE_RD ? TREE_RD.tick(bb) : null;
            else result = TREE_C ? TREE_C.tick(bb) : null;

            // CRITICAL CHECK:
            if (!result || typeof result !== "object" || 
                isNaN(result.tx) || !isFinite(result.tx) || 
                isNaN(result.ty) || !isFinite(result.ty)) {
                return { tx: 500, ty: 300, action: "none" }; // Fallback to Center Ice
            }
            return result;
        } catch (e) {
            return { tx: 500, ty: 300, action: "none" };
        }
    }

    if (typeof registerStrategy === "function") {
        registerStrategy(
            STRATEGY_ID,
            "Ottawa",
            "Senators",
            "OTT",
            think,
            { main: "#820000", secondary: "#780000" }
        );
    }
})();
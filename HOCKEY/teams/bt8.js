// ==========================================
// STRATEGY: Generated by Builder V10 (Complete & Safe)
// ==========================================
(function() {
    const STRATEGY_ID = "BT_GEN_V10_" + Math.floor(Math.random()*999);
    const STRATEGY_NAME = "Builder Gen V10";

    // --- ENGINE ---
    class Node{constructor(){} tick(bb){return false;}}
    class ConditionNode extends Node{constructor(fn){super();this.fn=fn;} tick(bb){return this.fn(bb)?"SUCCESS":"FAILURE";}}
    class ActionNode extends Node{constructor(fn){super();this.fn=fn;} tick(bb){return this.fn(bb);}}
    class SequenceNode extends Node{constructor(c){super();this.children=c;} tick(bb){for(let n of this.children){let r=n.tick(bb);if(r!=="SUCCESS")return r;}return"SUCCESS";}}
    class SelectorNode extends Node{constructor(c){super();this.children=c;} tick(bb){for(let n of this.children){let r=n.tick(bb);if(r!=="FAILURE")return r;}return"FAILURE";}}

    // Safe Physics Prediction
    function predictPuckIntersection(p) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x, y: p.y };
        return { x: puck.x + puck.vx * 10, y: puck.y + puck.vy * 10 };
    }

    function makeBB(p) {
        const safeRX = (typeof RX !== 'undefined') ? RX : 500;
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const safeGoal2 = (typeof goal2 !== 'undefined') ? goal2 : 825;
        const myGoalX = (p.team === 0 ? safeGoal1 : safeGoal2);
        const enemyGoal = (p.team === 0 ? safeGoal2 : safeGoal1);
        const forwardDir = (enemyGoal > myGoalX ? 1 : -1);
        const carrier = getPlayerById(puck.ownerId);

        return {
            p, myGoalX, enemyGoal, forwardDir, safeRX,
            hasPuck: (puck.ownerId === p.id),
            loosePuck: (puck.ownerId === null),
            oppHasPuck: (carrier && carrier.team !== p.team),
            teamHasPuck: (carrier && carrier.team === p.team),
            inShotRange: (Math.hypot(enemyGoal - p.x, RY - p.y) < 200),
            puckInDefZone: (forwardDir === 1 ? puck.x < safeRX - 60 : puck.x > safeRX + 60),
            puckInOffZone: (forwardDir === 1 ? puck.x > safeRX + 60 : puck.x < safeRX - 60),
            puckInNeuZone: (Math.abs(puck.x - safeRX) <= 60), // Between the two blue lines
            interceptPoint: predictPuckIntersection(p),
            carryTarget: null, passTarget: null
        };
    }

    // --- CONDITIONS ---
    const condHasPuck = new ConditionNode(bb => bb.hasPuck);
    const condLoosePuck = new ConditionNode(bb => bb.loosePuck);
    const condInShotRange = new ConditionNode(bb => bb.inShotRange);
    const condTeamHasPuck = new ConditionNode(bb => bb.teamHasPuck);
    const condOppHasPuck = new ConditionNode(bb => bb.oppHasPuck);
    const condPuckInDefZone = new ConditionNode(bb => bb.puckInDefZone);
    const condPuckInOffZone = new ConditionNode(bb => bb.puckInOffZone);
    const condPuckInNeuZone = new ConditionNode(bb => bb.puckInNeuZone);

    const condForwardLaneClear = new ConditionNode(bb => {
        bb.carryTarget = { x: bb.p.x + bb.forwardDir * 100, y: bb.p.y };
        return !isLaneBlocked(bb.p.x, bb.p.y, bb.carryTarget.x, bb.carryTarget.y, bb.p.team);
    });

    const condHasBreakoutPass = new ConditionNode(bb => {
        for (let m of players) {
            // FIX: Add "&& m.type === 'skater'" to this line
            if (m.team === bb.p.team && m.id !== bb.p.id && m.type === 'skater' && (m.x - bb.p.x) * bb.forwardDir > 0) {
                if (!isLaneBlocked(bb.p.x, bb.p.y, m.x, m.y, bb.p.team)) {
                    bb.passTarget = m;
                    return true;
                }
            }
        }
        return false;
    });


    // Checks if the carrier is surrounded by enemies
    const condIsPressured = new ConditionNode(bb => {
        let pressureCount = 0;
        for (const o of players) {
            if (o.team !== bb.p.team && Math.hypot(o.x - bb.p.x, o.y - bb.p.y) < 80) {
                pressureCount++;
            }
        }
        return pressureCount >= 2;
    });

    // FIXED: Safe Am I Closest
    const condAmIClosest = new ConditionNode(bb => {
        let c = null, d = 9999;
        for (let m of players) {
            if (m.team === bb.p.team) {
                let dist = Math.hypot(m.x - puck.x, m.y - puck.y);
                if (dist < d) { d = dist; c = m; }
            }
        }
        return c && c.id === bb.p.id;
    });

    // --- ACTIONS ---
    const actShoot = new ActionNode(bb => ({ tx: bb.enemyGoal, ty: RY, action: "shoot" }));

    // UPDATED: Stops 40px short to avoid getting stuck in net
    const actDriveNet = new ActionNode(bb => ({ 
        tx: bb.enemyGoal - (bb.forwardDir * 40), 
        ty: RY, 
        action: "none" 
    }));
    
    // UPDATED: Wingers stay in their lanes (Left stays Top, Right stays Bottom)
    const actHoverBlueLine = new ActionNode(bb => {
        let yOff = 0;
        if (bb.p.role === 'LW' || bb.p.role === 'LD') yOff = -100;
        if (bb.p.role === 'RW' || bb.p.role === 'RD') yOff = 100;
        return { tx: (bb.forwardDir === 1 ? bb.safeRX + 60 : bb.safeRX - 60), ty: RY + yOff, action: "none" };
    });

    const actTagUp_T1 = new ActionNode(bb => ({ tx: bb.safeRX - bb.forwardDir * 50, ty: RY, action: "none" }));
    const actIdle = new ActionNode(bb => ({ tx: bb.p.x, ty: bb.p.y, action: "none" }));
    const actChill = new ActionNode(bb => ({ tx: bb.p.x, ty: bb.p.y, action: "none" }));

    // Robust Intercept (Physics Version)
    const actSmartIntercept = new ActionNode(bb => {
        // Use the physics solver in helpers.js (Fixes orbiting)
        const target = getPuckIntercept(bb.p);
        return { 
            tx: target.x, 
            ty: target.y, 
            action: "none" 
        };
    });

    // UPDATED: Carry Wide if no specific target (Creates spacing)
    const actExecuteCarry = new ActionNode(bb => {
        if (bb.carryTarget) return { tx: bb.carryTarget.x, ty: bb.carryTarget.y, action: "none" };
        
        let yOff = 0;
        if (bb.p.role === 'LW' || bb.p.role === 'LD') yOff = -120; // Wide Lane
        if (bb.p.role === 'RW' || bb.p.role === 'RD') yOff = 120;
        
        return { tx: bb.enemyGoal, ty: RY + yOff, action: "none" };
    });

    const actExecutePass = new ActionNode(bb => {
        if (bb.passTarget) return { tx: bb.passTarget.x, ty: bb.passTarget.y, action: "pass", target: bb.passTarget };
        return { tx: bb.enemyGoal, ty: RY, action: "none" };
    });

    // UPDATED: Defenders split up (Box formation instead of huddle)
    const actDefendHome = new ActionNode(bb => {
        let yOff = 0;
        if (bb.p.role === 'LD' || bb.p.role === 'LW') yOff = -60;
        if (bb.p.role === 'RD' || bb.p.role === 'RW') yOff = 60;
        return {
            tx: bb.myGoalX + (bb.forwardDir * 120),
            ty: RY + yOff,
            action: 'none'
        };
    });

    // UPDATED: Deep Retreat + Lane Spacing
    const actRegroup = new ActionNode(bb => {
        let yOff = 0;
        if (bb.p.role === 'LD') yOff = -70; 
        if (bb.p.role === 'RD') yOff = 70;  
        return { 
            tx: bb.myGoalX + (bb.forwardDir * 150), 
            ty: RY + yOff, 
            action: "none" 
        };
    });

    // --- TREES ---
    const TREE_ATTACKER = 
        new SelectorNode([
            new SequenceNode([
                condHasPuck,
                condInShotRange,
                actShoot
            ]),
            new SequenceNode([
                condHasPuck,
                condIsPressured,
                condHasBreakoutPass,
                actExecutePass
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInDefZone,
                new SelectorNode([
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new ActionNode(bb => clearPuckDefensive(bb.p))
                ])
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInOffZone,
                new SelectorNode([
                    new SequenceNode([
                        condInShotRange,
                        actShoot
                    ]),
                    new SequenceNode([
                        new ConditionNode(bb => {
            const target = findBackdoorTarget(bb.p);
            if (target) {
                bb.passTarget = target; // Save it for the Action Node
                return true;
            }
            return false;
        }),
                        actExecutePass
                    ]),
                    actDriveNet
                ])
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInNeuZone,
                new SelectorNode([
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    actExecuteCarry
                ])
            ]),
            new SequenceNode([
                condTeamHasPuck,
                new ActionNode(bb => {
            const carrier = getPlayerById(puck.ownerId);
            if (!carrier) return { tx: bb.p.x, ty: bb.p.y, action:'none' };
            const finalX = carrier.x + (bb.forwardDir * -70);
            const finalY = (bb.p.y < RY) ? carrier.y - 0 : carrier.y + 0;
            return { tx: finalX, ty: finalY, action:'none' };
        })
            ]),
            new SequenceNode([
                condOppHasPuck,
                actDefendHome
            ]),
            actSmartIntercept
        ]);

    const TREE_WINGER = 
        new SelectorNode([
            new SequenceNode([
                condHasPuck,
                condInShotRange,
                actShoot
            ]),
            new SequenceNode([
                condHasPuck,
                condIsPressured,
                condHasBreakoutPass,
                actExecutePass
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInDefZone,
                new SelectorNode([
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new ActionNode(bb => clearPuckDefensive(bb.p))
                ])
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInOffZone,
                actDriveNet
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInNeuZone,
                new SelectorNode([
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    actExecuteCarry
                ])
            ]),
            new SequenceNode([
                condTeamHasPuck,
                new ActionNode(bb => {
            const carrier = getPlayerById(puck.ownerId);
            if (!carrier) return { tx: bb.p.x, ty: bb.p.y, action:'none' };
            const finalX = carrier.x + (bb.forwardDir * 20);
            const finalY = (bb.p.y < RY) ? carrier.y - 90 : carrier.y + 90;
            return { tx: finalX, ty: finalY, action:'none' };
        })
            ]),
            new SequenceNode([
                condOppHasPuck,
                actDefendHome
            ]),
            actSmartIntercept
        ]);

    const TREE_DEFENDER = 
        new SelectorNode([
            new SequenceNode([
                condHasPuck,
                condPuckInDefZone,
                new SelectorNode([
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new ActionNode(bb => clearPuckDefensive(bb.p))
                ])
            ]),
            new SequenceNode([
                condHasPuck,
                condIsPressured,
                condHasBreakoutPass,
                actExecutePass
            ]),
            new SequenceNode([
                condHasPuck,
                condPuckInNeuZone,
                new SelectorNode([
                    new SequenceNode([
                        condHasBreakoutPass,
                        actExecutePass
                    ]),
                    new ActionNode(bb => ({ 
            // Target: 150px in front of our own net (Deep Retreat)
            tx: bb.myGoalX + (bb.forwardDir * 150), 
            ty: RY, 
            action: "none" 
        }))
                ])
            ]),
            new SequenceNode([
                condHasPuck,
                actExecuteCarry
            ]),
            new SequenceNode([
                condTeamHasPuck,
                new ActionNode(bb => {
            const carrier = getPlayerById(puck.ownerId);
            if (!carrier) return { tx: bb.p.x, ty: bb.p.y, action:'none' };
            const finalX = carrier.x + (bb.forwardDir * -120);
            const finalY = (bb.p.y < RY) ? carrier.y - 0 : carrier.y + 0;
            return { tx: finalX, ty: finalY, action:'none' };
        })
            ]),
            new SequenceNode([
                condOppHasPuck,
                actDefendHome
            ]),
            actSmartIntercept
        ]);

    // --- MAIN BRAIN ---
    function think(p) {
        const bb = makeBB(p);
        let result = null;
        const role = p.role;
        if (role === "C") result = TREE_ATTACKER.tick(bb);
        else if (role === "A" || role === "D" || role === "LD" || role === "RD") result = TREE_DEFENDER.tick(bb);
        else result = TREE_WINGER.tick(bb);

        if (!result || typeof result === "string" || isNaN(result.tx)) {
            return { tx: p.x, ty: p.y, action: "none" };
        }
        return result;
    }













    // ==========================================
    // REGISTER
    // ==========================================
    if (typeof registerStrategy === "function") {
        registerStrategy(
            STRATEGY_ID,
            STRATEGY_NAME,
            "Canadiens",
            "MTL",
            think,
            { main: "#af1e2d", secondary: "#192168" } // Red - Blue
        );
    }

})();
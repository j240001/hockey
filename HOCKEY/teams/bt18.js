// Trained (ANA) - Generated by Builder V30 (Safe Mode)
(function() {
    const STRATEGY_ID = "BT_" + "ANA_" + Math.floor(Math.random() * 99999);

    // --- ENGINE ---
    class Node { constructor() {} tick(bb) { return false; } }
    class ConditionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb) ? "SUCCESS" : "FAILURE"; } }
    class ActionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb); } }
    class SequenceNode extends Node { constructor(c) { super(); this.children = c; } tick(bb) { for (let n of this.children) { let r = n.tick(bb); if (r !== "SUCCESS") return r; } return "SUCCESS"; } }
    class SelectorNode extends Node { constructor(c) { super(); this.children = c; } tick(bb) { for (let n of this.children) { let r = n.tick(bb); if (r !== "FAILURE") return r; } return "FAILURE"; } }


    // --- CORE HELPERS (Math & Vision) ---
    function clamp(v, lo, hi) { return v < lo ? lo : (v > hi ? hi : v); }
    function normalizeAngle(a) { while (a <= -Math.PI) a += 2 * Math.PI; while (a > Math.PI) a -= 2 * Math.PI; return a; }
    function pointLineDistance(x1, y1, x2, y2, px, py) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A*C + B*D, lenSq = C*C + D*D;
        if (lenSq < 0.001) return Math.hypot(px - x1, py - y1); // Avoid Zero Div
        const t = Math.max(0, Math.min(1, dot / lenSq));
        return Math.hypot(px - (x1 + t * C), py - (y1 + t * D));
    }
    function getPlayerById(id) { return (typeof players !== 'undefined') ? players.find(p => p.id === id) : null; }
    function getPuckCarrier() { return (typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null; }
    function isLaneBlocked(x1, y1, x2, y2, team) {
        if (typeof players === 'undefined') return false;
        for (const o of players) {
            if (o.team === team) continue;
            if (pointLineDistance(x1, y1, x2, y2, o.x, o.y) < 18) return true;
        }
        return false;
    }
    function predictPuckIntersection(p) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x, y: p.y };
        return { x: puck.x + puck.vx * 10, y: puck.y + puck.vy * 10 };
    }
    function getPuckIntercept(p) {
        if (typeof puck === 'undefined') return {x: p.x, y: p.y};
        const dist = Math.hypot(puck.x - p.x, puck.y - p.y);
        const frames = dist / 4.0; 
        let tx = puck.x + puck.vx * frames;
        let ty = puck.y + puck.vy * frames;
        tx = Math.max(120, Math.min(880, tx));
        ty = Math.max(170, Math.min(430, ty));
        return { x: tx, y: ty };
    }
    
    function findSmartPass(p, bb) {
        let best = null, bestScore = -999;
        const skaters = players.filter(m => m.team === p.team && m.id !== p.id && m.type === "skater");
        for (const mate of skaters) {
            if (isLaneBlocked(p.x, p.y, mate.x, mate.y, p.team)) continue;
            let score = -Math.hypot(mate.x - bb.enemyGoal, mate.y - (typeof RY!=='undefined'?RY:300));
            for (const o of players) {
                if (o.team !== p.team && Math.hypot(o.x - mate.x, o.y - mate.y) < 60) score -= 1000;
            }
            if (score > bestScore) { bestScore = score; best = mate; }
        }
        return best;
    }
    function condWeightedPassCheck(bb, bias, fear, vision) {
        // --- TUNING SECTION (Adjust these to change Team Physics) ---
        const FWD_BONUS = 3.0;          // Points added for moving closer to enemy net
        const BWD_PENALTY = -6.0;       // Points subtracted for moving away from enemy net
        const BLUE_LINE_PENALTY = -20.0;// Penalty for passing out of the Offensive Zone
        const MIN_PASS_DIST = 50;       // Minimum pixel distance (Safety)
        // -----------------------------------------------------------

        const p = bb.p;
        
        // 1. Calculate Pressure (0.0 to 2.0)
        let enemyPressure = 0;
        if (typeof players !== 'undefined') {
            for (const o of players) {
                if (o.team === p.team) continue;
                const d = Math.hypot(o.x - p.x, o.y - p.y);
                if (d < 60) enemyPressure += 1.0; else if (d < 120) enemyPressure += 0.5;
            }
        }
        enemyPressure = Math.min(2.0, enemyPressure);

        // 2. Evaluate Teammates
        let bestTeammateScore = -999; 
        let bestTarget = null;
        const teammates = (typeof players !== 'undefined') ? players.filter(m => m.team === p.team && m.id !== p.id && m.type !== 'goalie') : [];
        
        for (const mate of teammates) {
            const d = Math.hypot(mate.x - p.x, mate.y - p.y);
            
            // Safety Check
            if (d < MIN_PASS_DIST) continue; 

            let distScore = (d > 100 && d < 400) ? 1.0 : 0.2;
            let laneBlocked = isLaneBlocked(p.x, p.y, mate.x, mate.y, p.team);
            
            if (!laneBlocked) {
                // DISTANCE LOGIC
                const myDist = Math.hypot(p.x - bb.enemyGoal, p.y - 300);
                const mateDist = Math.hypot(mate.x - bb.enemyGoal, mate.y - 300);
                
                // PROGRESS SCORE (Uses your Tuning Variables)
                let progressScore = (myDist - mateDist) > 0 ? FWD_BONUS : BWD_PENALTY;

                // BLUE LINE LOGIC
                const myRelX = (p.x - bb.safeRX) * bb.forwardDir;     
                const mateRelX = (mate.x - bb.safeRX) * bb.forwardDir;
                // If I am deep (25px past center) and mate is not...
                if (myRelX > 25 && mateRelX < 25) {
                    progressScore += BLUE_LINE_PENALTY; 
                }

                const total = distScore + progressScore;
                if (total > bestTeammateScore) { bestTeammateScore = total; bestTarget = mate; }
            }
        }

        // 3. Final Score Calculation
        // Formula: Bias + (Pressure * Fear) + (BestOption * Vision)
        let passScore = (bias * 1.0) + (enemyPressure * fear * 1.5) + (bestTeammateScore * vision * 2.0);
        let carryScore = (100 - bias);
        
        // Open Ice Carry Bonus
        let closestEnemy = 999;
        if (typeof players !== 'undefined') { for(const o of players) { if(o.team !== p.team) closestEnemy = Math.min(closestEnemy, Math.hypot(o.x-p.x, o.y-p.y)); } }
        if (closestEnemy > 150) carryScore += 50;

        // Threshold to Pass
        // Note: bestTeammateScore must be > -10 to prevent passing to a terrible option just because carryScore is low
        if (passScore > carryScore && bestTarget !== null && bestTeammateScore > -10.0) { 
            bb.passTarget = bestTarget; 
            return true; 
        }
        return false;
    }

    function makeBB(p) {
        const safeRX = (typeof RX !== 'undefined') ? RX : 500;
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const safeGoal2 = (typeof goal2 !== 'undefined') ? goal2 : 825;
        const myGoalX = (p.team === 0 ? safeGoal1 : safeGoal2);
        const enemyGoal = (p.team === 0 ? safeGoal2 : safeGoal1);
        const forwardDir = (enemyGoal > myGoalX ? 1 : -1);
        const carrier = (typeof getPlayerById === 'function' && typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null;

        return {
            p, myGoalX, enemyGoal, forwardDir, safeRX,
            hasPuck: (typeof puck !== 'undefined' && puck.ownerId === p.id),
            loosePuck: (typeof puck !== 'undefined' && puck.ownerId === null),
            oppHasPuck: (carrier && carrier.team !== p.team),
            teamHasPuck: (carrier && carrier.team === p.team),
            inShotRange: (Math.hypot(enemyGoal - p.x, (typeof RY !== 'undefined' ? RY : 300) - p.y) < 200),
            puckInDefZone: (forwardDir === 1 ? puck.x < safeRX - 60 : puck.x > safeRX + 60),
            puckInOffZone: (forwardDir === 1 ? puck.x > safeRX + 60 : puck.x < safeRX - 60),
            puckInNeuZone: (Math.abs(puck.x - safeRX) <= 60),
            interceptPoint: predictPuckIntersection(p),
            carryTarget: null, passTarget: null
        };
    }

    // --- TREES ---
    const TREE_C = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 30, 50, 89) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 50, 50, 50) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 90, 80, 40) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 52), ty: (typeof RY !== 'undefined' ? RY : 300) + -74, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.teamHasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 124), ty: (typeof RY !== 'undefined' ? RY : 300) + -101, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_LW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 2, 50, 60) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 50, 50, 50) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 90, 80, 30) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 24), ty: (typeof RY !== 'undefined' ? RY : 300) + -45, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.teamHasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 266), ty: (typeof RY !== 'undefined' ? RY : 300) + -126, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_RW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 20, 50, 60) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 50, 50, 50) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 90, 80, 30) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -9), ty: (typeof RY !== 'undefined' ? RY : 300) + 27, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.teamHasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 194), ty: (typeof RY !== 'undefined' ? RY : 300) + 130, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })])]);
    const TREE_LD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 50, 50, 70) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 70, 60, 60) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 95, 100, 40) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 13), ty: (typeof RY !== 'undefined' ? RY : 300) + -6, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.teamHasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -32), ty: (typeof RY !== 'undefined' ? RY : 300) + -92, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let c=null,d=9999;for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { let yOff=(bb.p.role==='LD'||bb.p.role==='LW')?-60:60; return {tx:bb.myGoalX+(bb.forwardDir*120),ty:(typeof RY !== 'undefined' ? RY : 300)+yOff,action:'none'}; })])]);
    const TREE_RD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 50, 50, 70) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInNeuZone),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 52, 60, 77) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => { try { return (typeof condWeightedPassCheck === 'function' ? condWeightedPassCheck(bb, 95, 80, 40) : false); } catch(e){return false;} }),
                new ActionNode(bb => { try { if(bb.passTarget)return{tx:bb.passTarget.x,ty:bb.passTarget.y,action:"pass",target:bb.passTarget}; return null; } catch(e){return null;} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 36), ty: (typeof RY !== 'undefined' ? RY : 300) + -7, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.teamHasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -50), ty: (typeof RY !== 'undefined' ? RY : 300) + 100, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ConditionNode(bb => {let c=null,d=9999;for(let m of players){if(m.team===bb.p.team && m.type==='skater'){let dist=Math.hypot(m.x-puck.x,m.y-puck.y);if(dist<d){d=dist;c=m;}}}return c&&c.id===bb.p.id;}),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { let yOff=(bb.p.role==='LD'||bb.p.role==='LW')?-60:60; return {tx:bb.myGoalX+(bb.forwardDir*120),ty:(typeof RY !== 'undefined' ? RY : 300)+yOff,action:'none'}; })])]);

    // --- MAIN BRAIN (ANTI-VANISH SHIELD) ---
    function think(p) {
        try {
            const bb = makeBB(p);
            let result = null;

            if (p.role === "C") result = TREE_C ? TREE_C.tick(bb) : null;
            else if (p.role === "LW") result = TREE_LW ? TREE_LW.tick(bb) : null;
            else if (p.role === "RW") result = TREE_RW ? TREE_RW.tick(bb) : null;
            else if (p.role === "LD") result = TREE_LD ? TREE_LD.tick(bb) : null;
            else if (p.role === "RD") result = TREE_RD ? TREE_RD.tick(bb) : null;
            else result = TREE_C ? TREE_C.tick(bb) : null;

            // CRITICAL CHECK:
            if (!result || typeof result !== "object" || 
                isNaN(result.tx) || !isFinite(result.tx) || 
                isNaN(result.ty) || !isFinite(result.ty)) {
                return { tx: 500, ty: 300, action: "none" }; // Fallback to Center Ice
            }
            return result;
        } catch (e) {
            return { tx: 500, ty: 300, action: "none" };
        }
    }

    if (typeof registerStrategy === "function") {
        registerStrategy(
            STRATEGY_ID,
            "Trained",
            "Ducks",
            "ANA",
            think,
            { main: "#ff9500", secondary: "#eb4600" }
        );
    }
})();
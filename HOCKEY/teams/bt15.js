// trained (PIT) - Generated by Builder V30 (Safe Mode)
(function() {
    const STRATEGY_ID = "BT_" + "PIT_" + Math.floor(Math.random() * 99999);

    // --- ENGINE ---
    class Node { constructor() {} tick(bb) { return false; } }
    class ConditionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb) ? "SUCCESS" : "FAILURE"; } }
    class ActionNode extends Node { constructor(fn) { super(); this.fn = fn; } tick(bb) { return this.fn(bb); } }
    class SequenceNode extends Node { constructor(c) { super(); this.children = c; } tick(bb) { for (let n of this.children) { let r = n.tick(bb); if (r !== "SUCCESS") return r; } return "SUCCESS"; } }
    class SelectorNode extends Node { constructor(c) { super(); this.children = c; } tick(bb) { for (let n of this.children) { let r = n.tick(bb); if (r !== "FAILURE") return r; } return "FAILURE"; } }


    // --- CORE HELPERS (Math & Vision) ---
    function clamp(v, lo, hi) { return v < lo ? lo : (v > hi ? hi : v); }
    function normalizeAngle(a) { while (a <= -Math.PI) a += 2 * Math.PI; while (a > Math.PI) a -= 2 * Math.PI; return a; }
    function pointLineDistance(x1, y1, x2, y2, px, py) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A*C + B*D, lenSq = C*C + D*D;
        if (lenSq < 0.001) return Math.hypot(px - x1, py - y1); // Avoid Zero Div
        const t = Math.max(0, Math.min(1, dot / lenSq));
        return Math.hypot(px - (x1 + t * C), py - (y1 + t * D));
    }
    function getPlayerById(id) { return (typeof players !== 'undefined') ? players.find(p => p.id === id) : null; }
    function getPuckCarrier() { return (typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null; }
    function isLaneBlocked(x1, y1, x2, y2, team) {
        if (typeof players === 'undefined') return false;
        for (const o of players) {
            if (o.team === team) continue;
            if (pointLineDistance(x1, y1, x2, y2, o.x, o.y) < 18) return true;
        }
        return false;
    }
    function predictPuckIntersection(p) {
        if (typeof puck === 'undefined' || isNaN(puck.x)) return { x: p.x, y: p.y };
        return { x: puck.x + puck.vx * 10, y: puck.y + puck.vy * 10 };
    }
    function getPuckIntercept(p) {
        if (typeof puck === 'undefined') return {x: p.x, y: p.y};
        const dist = Math.hypot(puck.x - p.x, puck.y - p.y);
        const frames = dist / 4.0; 
        let tx = puck.x + puck.vx * frames;
        let ty = puck.y + puck.vy * frames;
        tx = Math.max(120, Math.min(880, tx));
        ty = Math.max(170, Math.min(430, ty));
        return { x: tx, y: ty };
    }
    
    function amILastMan(p) {
        const myGoalX = (p.team === 0 ? (typeof goal1 !== 'undefined' ? goal1 : 175) : (typeof goal2 !== 'undefined' ? goal2 : 825));
        const myDist = Math.abs(p.x - myGoalX);
        for (const mate of players) {
            if (mate.team !== p.team || mate.id === p.id || mate.type !== "skater") continue;
            if (Math.abs(mate.x - myGoalX) < myDist) return false;
        }
        return true;
    }
    function getLastManSafetyTarget(p) {
        const myGoalX = (p.team === 0 ? (typeof goal1 !== 'undefined' ? goal1 : 175) : (typeof goal2 !== 'undefined' ? goal2 : 825));
        const myGoalY = (typeof RY !== 'undefined' ? RY : 300);
        const attackDir = (myGoalX < 500) ? 1 : -1;
        let closestDist = 9999, dangerOpp = null;
        for (const o of players) {
            if (o.team === p.team) continue;
            const d = Math.abs(o.x - myGoalX);
            if (d < closestDist) { closestDist = d; dangerOpp = o; }
        }
        if (!dangerOpp) return { tx: myGoalX + (attackDir * 150), ty: myGoalY, action: "none" };
        let targetX = dangerOpp.x - (attackDir * 180);
        if (attackDir === 1 && targetX < myGoalX + 120) targetX = myGoalX + 120;
        if (attackDir === -1 && targetX > myGoalX - 120) targetX = myGoalX - 120;
        const totalDistX = myGoalX - dangerOpp.x;
        const myDistX = targetX - dangerOpp.x;
        if (Math.abs(totalDistX) < 1) return { tx: targetX, ty: myGoalY, action: "none" };
        const ratio = myDistX / totalDistX;
        let targetY = dangerOpp.y + (myGoalY - dangerOpp.y) * ratio;
        targetY = Math.max(160, Math.min(440, targetY));
        return { tx: targetX, ty: targetY, action: "none" };
    }
    function getAggressiveGapTarget(defender, carrier, goalX) {
        const IDEAL_GAP = 75; const MIN_DIST_FROM_NET = 80;
        const gx = goalX; const gy = (typeof RY!=='undefined'?RY:300);
        const target = carrier || {x:0, y:0};
        const dx = target.x - gx; const dy = target.y - gy;
        const distToCarrier = Math.max(1, Math.hypot(dx, dy)); // SAFETY: No Zero Div
        let tx, ty;
        if (distToCarrier < MIN_DIST_FROM_NET + 10) {
            const aggressiveGap = Math.max(35, distToCarrier - MIN_DIST_FROM_NET);
            const t = (distToCarrier - aggressiveGap) / distToCarrier;
            tx = gx + t * dx; ty = gy + t * dy;
        } else {
            const t = Math.max(0, (distToCarrier - IDEAL_GAP) / distToCarrier);
            tx = gx + t * dx; ty = gy + t * dy;
        }
        if (!isFinite(tx) || !isFinite(ty)) return { tx: 500, ty: 300, action: "none" }; // SAFETY
        const distToTarget = Math.hypot(tx - defender.x, ty - defender.y);
        const myDistToNet = Math.hypot(defender.x - gx, defender.y - gy);
        const isBeat = distToCarrier < myDistToNet;
        if (isBeat || distToTarget > 120) { return { tx: tx, ty: ty, action: "none" }; }
        return { tx: tx, ty: ty, action: "none" }; 
    }

    function makeBB(p) {
        const safeRX = (typeof RX !== 'undefined') ? RX : 500;
        const safeGoal1 = (typeof goal1 !== 'undefined') ? goal1 : 175;
        const safeGoal2 = (typeof goal2 !== 'undefined') ? goal2 : 825;
        const myGoalX = (p.team === 0 ? safeGoal1 : safeGoal2);
        const enemyGoal = (p.team === 0 ? safeGoal2 : safeGoal1);
        const forwardDir = (enemyGoal > myGoalX ? 1 : -1);
        const carrier = (typeof getPlayerById === 'function' && typeof puck !== 'undefined' && puck.ownerId !== null) ? getPlayerById(puck.ownerId) : null;

        return {
            p, myGoalX, enemyGoal, forwardDir, safeRX,
            hasPuck: (typeof puck !== 'undefined' && puck.ownerId === p.id),
            loosePuck: (typeof puck !== 'undefined' && puck.ownerId === null),
            oppHasPuck: (carrier && carrier.team !== p.team),
            teamHasPuck: (carrier && carrier.team === p.team),
            inShotRange: (Math.hypot(enemyGoal - p.x, (typeof RY !== 'undefined' ? RY : 300) - p.y) < 200),
            puckInDefZone: (forwardDir === 1 ? puck.x < safeRX - 60 : puck.x > safeRX + 60),
            puckInOffZone: (forwardDir === 1 ? puck.x > safeRX + 60 : puck.x < safeRX - 60),
            puckInNeuZone: (Math.abs(puck.x - safeRX) <= 60),
            interceptPoint: predictPuckIntersection(p),
            carryTarget: null, passTarget: null
        };
    }

    // --- TREES ---
    const TREE_C = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { try { return (typeof getAggressiveGapTarget === 'function' ? getAggressiveGapTarget(bb.p, (typeof getPuckCarrier === 'function' ? getPuckCarrier() : puck), bb.myGoalX) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof amILastMan === 'function' ? amILastMan(bb.p) : false); } catch(e){return false;} }),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -150), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))])]);
    const TREE_LW = 
null;
    const TREE_RW = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ActionNode(bb => { if(bb.carryTarget)return{tx:bb.carryTarget.x,ty:bb.carryTarget.y,action:"none"}; return {tx:bb.enemyGoal,ty:(typeof RY !== 'undefined' ? RY : 300),action:"none"}; })]),
            new SequenceNode([                new ConditionNode(bb => bb.loosePuck),
                new ActionNode(bb => { try { const t = (typeof getPuckIntercept==='function')?getPuckIntercept(bb.p):{x:puck.x,y:puck.y}; return {tx:t.x,ty:t.y,action:"none"}; } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:"none"};} })]),
            new SequenceNode([                new ConditionNode(bb => { try { return (typeof amILastMan === 'function' ? amILastMan(bb.p) : false); } catch(e){return false;} }),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -150), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.inShotRange),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => bb.puckInDefZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -200), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.hasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.enemyGoal, ty: (typeof RY !== 'undefined' ? RY : 300), action: "shoot" }))]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ActionNode(bb => { try { return (typeof getAggressiveGapTarget === 'function' ? getAggressiveGapTarget(bb.p, (typeof getPuckCarrier === 'function' ? getPuckCarrier() : puck), bb.myGoalX) : {tx:bb.p.x,ty:bb.p.y,action:'none'}); } catch(e){return {tx:bb.p.x,ty:bb.p.y,action:'none'};} })])]);
    const TREE_LD = 
        new SelectorNode([            new SequenceNode([                new ConditionNode(bb => { try { return (typeof amILastMan === 'function' ? amILastMan(bb.p) : false); } catch(e){return false;} }),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -150), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.oppHasPuck),
                new ConditionNode(bb => bb.puckInDefZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * -200), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))]),
            new SequenceNode([                new ConditionNode(bb => bb.teamHasPuck),
                new ConditionNode(bb => bb.puckInOffZone),
                new ActionNode(bb => ({ tx: bb.safeRX + (bb.forwardDir * 100), ty: (typeof RY !== 'undefined' ? RY : 300) + 0, action: 'none' }))])]);
    const TREE_RD = 
null;

    // --- MAIN BRAIN (ANTI-VANISH SHIELD) ---
    function think(p) {
        try {
            const bb = makeBB(p);
            let result = null;

            if (p.role === "C") result = TREE_C ? TREE_C.tick(bb) : null;
            else if (p.role === "LW") result = TREE_LW ? TREE_LW.tick(bb) : null;
            else if (p.role === "RW") result = TREE_RW ? TREE_RW.tick(bb) : null;
            else if (p.role === "LD") result = TREE_LD ? TREE_LD.tick(bb) : null;
            else if (p.role === "RD") result = TREE_RD ? TREE_RD.tick(bb) : null;
            else result = TREE_C ? TREE_C.tick(bb) : null;

            // CRITICAL CHECK:
            if (!result || typeof result !== "object" || 
                isNaN(result.tx) || !isFinite(result.tx) || 
                isNaN(result.ty) || !isFinite(result.ty)) {
                return { tx: 500, ty: 300, action: "none" }; // Fallback to Center Ice
            }
            return result;
        } catch (e) {
            return { tx: 500, ty: 300, action: "none" };
        }
    }

    if (typeof registerStrategy === "function") {
        registerStrategy(
            STRATEGY_ID,
            "trained",
            "Penguins",
            "PIT",
            think,
            { main: "#0f0400", secondary: "#fae500" }
        );
    }
})();